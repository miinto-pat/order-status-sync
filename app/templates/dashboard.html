<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-dark bg-dark">
    <div class="container-fluid">
        <a class="navbar-brand" href="#">Miinto Affiliate Order Automation Dashboard</a>
        <div class="d-flex">
            <span class="navbar-text me-3 text-white">{{ current_user.id }}</span>
            <a class="btn btn-outline-light" href="{{ url_for('bp.logout') }}">Logout</a>
        </div>
    </div>
</nav>


<div class="container mt-5">
    <h3></h3>
    <p class="text-muted">
    This bot automates order status updates between Impact and Miinto Admin to ensure accurate, VAT-excluded commission reporting.
</p>
    <form id="runBotForm">
        <div class="row mb-3">
        <div class="mb-3">
    <label class="form-label fw-bold">Select Markets</label>
    <div class="d-flex flex-wrap gap-2">
        {% for campaign_id, code in markets.items() %}
            <div class="form-check form-check-inline m-0">
                <input class="form-check-input" type="checkbox"
                       name="markets"
                       value="{{ campaign_id }}"
                       id="market_{{ code }}">
                <label class="form-check-label small" for="market_{{ code }}">
                    {{ code }}
                </label>
            </div>
        {% endfor %}
    </div>
</div>

        <div class="col">
            <label for="startDate" class="form-label">Start Date</label>
            <input type="date" id="startDate" name="start_date" class="form-control">
        </div>
        <div class="col">
            <label for="endDate" class="form-label">End Date</label>
            <input type="date" id="endDate" name="end_date" class="form-control">
        </div>
    </div>
    <button type="submit" id="runBotBtn" class="btn btn-success mb-3">Run Bot</button>
</form>

<div id="progressMessage" class="alert alert-info mt-2">Bot is idle. Please choose a start and end date, then click “Run Bot”.</div>
    <div id="marketStats" class="mt-3"></div>

    {% with messages = get_flashed_messages() %}
    {% if messages %}
        <div class="alert alert-info">
            {% for msg in messages %}{{ msg }}<br>{% endfor %}
        </div>
    {% endif %}
    {% endwith %}
<script>
document.getElementById("runBotForm").addEventListener("submit", function(e) {
    e.preventDefault();

    const btn = document.getElementById("runBotBtn");
    const msgDiv = document.getElementById("progressMessage");
    const statsDiv = document.getElementById("marketStats");

    const startDate = document.getElementById("startDate").value;
    const endDate = document.getElementById("endDate").value;

    // Get selected markets
    const selectedMarkets = Array.from(document.querySelectorAll("input[name='markets']:checked"))
                                 .map(cb => cb.value);

    let missingFields = [];

    if (!startDate) missingFields.push("start date");
    if (!endDate) missingFields.push("end date");
    if (selectedMarkets.length === 0) missingFields.push("at least one market");

    if (missingFields.length > 0) {
        msgDiv.className = "alert alert-danger mt-2";
        msgDiv.innerText = "Please select " + missingFields.join(", ") + ".";
        btn.disabled = false;
        return;
    }

    if (new Date(endDate) < new Date(startDate)) {
        msgDiv.className = "alert alert-danger mt-2";
        msgDiv.innerText = "End date must be after the start date.";
        return;
    }

    // Reset UI
    msgDiv.className = "alert alert-info mt-2";
    msgDiv.innerText = "Starting bot...";
    statsDiv.innerHTML = "";
    btn.disabled = true;


    // Start bot
    fetch("{{ url_for('bp.run_bot') }}", {
        method: "POST",
        credentials: "same-origin",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ start_date: startDate,
         end_date: endDate,
         markets: selectedMarkets})
    })
    .then(resp => {
        if (!resp.ok) {
            // HTTP error -> show friendly message
            throw new Error("Error while retrieving actions");
        }
        return resp.json();
    })
    .then(data => {
        if (data.status === "error") {
            // Backend returned an error
            msgDiv.className = "alert alert-danger mt-2";
            msgDiv.innerText = "Error while retrieving actions";
            btn.disabled = false;
            return; // Stop further processing
        }

        msgDiv.className = "alert alert-info mt-2";
        msgDiv.innerText = data.message;

        // Start polling for bot status
        startPolling();
    })
    .catch(err => {
        msgDiv.className = "alert alert-danger mt-2";
        msgDiv.innerText = err.message || "Error starting bot.";
        btn.disabled = false;
        console.error(err);
    });

    // Polling function separated
    function startPolling() {
    const interval = setInterval(() => {
        fetch("{{ url_for('bp.bot_status_endpoint') }}")
            .then(resp => resp.json())
.then(status => {
    msgDiv.innerText = status.message || "Running...";

    // Always ensure main results table exists
  // --- Ensure main results table exists (once) ---
if (!document.getElementById("liveResultsTable")) {
    statsDiv.innerHTML = `
        <table id="liveResultsTable" class="table table-sm table-bordered">
            <thead>
                <tr>
                    <th>Market</th>
                    <th>Total</th>
                    <th>VOUCHER/Rejections</th>
                    <th>FULLY_RETURNED</th>
                    <th>ORDER_UPDATE</th>
                    <th>Not Modified</th>
                    <th>Not Processed</th>
                </tr>
            </thead>
            <tbody id="marketRows"></tbody>
        </table>
        <div id="errorSummary" class="mt-3"></div>
    `;
}

const tbody = document.getElementById("marketRows");

// ✅ Update or append rows for markets dynamically (no clearing)
if (status.market_stats && Object.keys(status.market_stats).length > 0) {
    for (const [market, s] of Object.entries(status.market_stats)) {
        // Try to find existing row for this market
        let row = tbody.querySelector(`tr[data-market="${market}"]`);

        // Create a new row if it doesn’t exist
        if (!row) {
            row = document.createElement("tr");
            row.dataset.market = market;
            row.innerHTML = `
                <td>${market}</td>
                <td>0</td>
                <td>0</td>
                <td>0</td>
                <td>0</td>
                <td>0</td>
                <td>0</td>
            `;
            tbody.appendChild(row);
        }

        // Update row cells with latest stats
        const cells = row.querySelectorAll("td");
        cells[1].textContent = s.total_actions ?? 0;
        cells[2].textContent = s.OTHER ?? 0;
        cells[3].textContent = s.ITEM_RETURNED ?? 0;
        cells[4].textContent = s.ORDER_UPDATE ?? 0;
        cells[5].textContent = s.Not_Modified ?? 0;
        cells[6].textContent = s.Not_Processed ?? 0;
    }
} else if (tbody.children.length === 0) {
    // Only show placeholder once when no data exists at all
    tbody.innerHTML = `<tr><td colspan="7" class="text-center text-muted">No market data yet.</td></tr>`;
}



// --- Render "Not Processed" actions table only when there are actual records ---
if (status.not_processed && status.not_processed.length > 0) {
    // ✅ Group Not Processed Actions by Market
    const groupedByMarket = status.not_processed.reduce((acc, entry) => {
        if (!acc[entry.market]) acc[entry.market] = [];
        acc[entry.market].push(entry.action_id);
        return acc;
    }, {});

    // ✅ Check if there is at least one valid market with records
    const validMarkets = Object.entries(groupedByMarket).filter(([_, ids]) => ids.length > 0);

    if (validMarkets.length > 0) {
        // ✅ Create the table if it doesn’t already exist
        if (!document.getElementById("notProcessedTable")) {
            statsDiv.insertAdjacentHTML("beforeend", `
                <div id="notProcessedWrapper" class="mt-4">
                    <h5>Not Processed Actions</h5>
                    <table id="notProcessedTable" class="table table-sm table-bordered mt-2">
                        <thead>
                            <tr>
                                <th>Market</th>
                                <th>Action IDs</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            `);
        }

        const tbody2 = document.querySelector("#notProcessedTable tbody");
        const existingMarkets = new Set([...tbody2.querySelectorAll("tr")].map(tr => tr.dataset.market));

        // ✅ Populate only markets with actual not processed actions
        for (const [market, actionIds] of validMarkets) {
    let row = tbody2.querySelector(`tr[data-market="${market}"]`);
    if (!row) {
        row = document.createElement("tr");
        row.dataset.market = market;
        tbody2.appendChild(row);
    }
    row.innerHTML = `<td>${market}</td><td>${actionIds.join(", ")}</td>`;
}

// Remove old markets no longer present
tbody2.querySelectorAll("tr").forEach(tr => {
    if (!groupedByMarket[tr.dataset.market]) tr.remove();
});





    // --- NEW: Show failed markets under main table ---
    let failedMarkets = [];

    // Collect failed markets from market_stats
    if (status.market_stats) {
        for (const [market, s] of Object.entries(status.market_stats)) {
            if (s.error) failedMarkets.push({ market, error: s.error });
        }
    }

    // Collect totally failed ones from not_processed
    if (status.not_processed && status.not_processed.length > 0) {
        status.not_processed.forEach(e => {
            if (e.action_id === "N/A" && e.error) {
                failedMarkets.push({ market: e.market, error: e.error });
            }
        });
    }

    // Remove duplicates
    const seen = new Set();
    failedMarkets = failedMarkets.filter(f => {
        if (seen.has(f.market)) return false;
        seen.add(f.market);
        return true;
    });

    // Render error summary below main table
    const errorSummaryDiv = document.getElementById("errorSummary");
    if (failedMarkets.length > 0) {
        errorSummaryDiv.className = "alert alert-danger";
        errorSummaryDiv.innerHTML = `
            <strong>⚠️ Some markets failed:</strong>
            <ul class="mb-0">
                ${failedMarkets.map(f => `<li><b>${f.market}</b>: ${f.error}</li>`).join("")}
            </ul>
        `;
    } else {
        errorSummaryDiv.innerHTML = "";
        errorSummaryDiv.className = "";
    }

    // Stop polling if finished or error
    if (["finished", "error"].includes(status.status)) {
        clearInterval(interval);
        btn.disabled = false;
        msgDiv.className =
            status.status === "finished"
                ? "alert alert-success mt-2"
                : "alert alert-danger mt-2";
    }
})



            .catch(err => {
                console.error("Polling error:", err);
                clearInterval(interval);
                btn.disabled = false;
            });
    }, 1000);
}

    // Function to render table only on successful completion
    function renderTable(marketStats) {
        if (!marketStats) return;

        let html = "<table class='table table-sm table-bordered'>";
        html += "<thead><tr><th>Market</th><th>Total</th><th>VOUCHER/Rejections</th><th>FULLY_RETURNED</th><th>ORDER_UPDATE</th><th>Not Modified</th><th>Not Processed</th></tr></thead><tbody>";

        for (const [market, s] of Object.entries(marketStats)) {
            html += `<tr>
                <td>${market}</td>
                <td>${s.total_actions || 0}</td>
                <td>${s.OTHER || 0}</td>
                <td>${s.ITEM_RETURNED || 0}</td>
                <td>${s.ORDER_UPDATE || 0}</td>
                <td>${s.Not_Modified || 0}</td>
                <td>${s.Not_Processed || 0}</td>
                <td>${s.error || ""}</td>
            </tr>`;
        }

        html += "</tbody></table>";
        statsDiv.innerHTML = html;
    }
});


</script>



</div>
</body>
</html>
